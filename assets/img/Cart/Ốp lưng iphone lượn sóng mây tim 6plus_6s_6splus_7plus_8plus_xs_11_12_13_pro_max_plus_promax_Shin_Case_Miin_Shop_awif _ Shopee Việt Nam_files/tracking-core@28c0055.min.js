self.window.trackingSDK.define(['exports'],function(exports){'use strict';/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}/**
 * A specific version of Queue copied from reqest-queue package so as to
 * further remove the dependency from request-queue. So we can well control
 * the storage strategy within tracker.
 */
var Queue = /** @class */ (function () {
    function Queue(storage, storageKey) {
        this.storage = storage;
        this.storageKey = storageKey;
    }
    Queue.prototype.get = function () {
        return this.storage.get(this.storageKey) || [];
    };
    Queue.prototype.set = function (data) {
        data = data || [];
        return this.storage.set(this.storageKey, data);
    };
    Queue.prototype.enqueue = function (obj) {
        var queue = this.get();
        queue.push(obj);
        this.set(queue);
    };
    Queue.prototype.batchDequeue = function (size) {
        var queue = this.get();
        var slice = queue.slice(0, size);
        var newQueue = queue.slice(size);
        this.set(newQueue);
        return slice;
    };
    Queue.prototype.putBackBatchToQueue = function (data) {
        return this.set(data.concat(this.get()));
    };
    return Queue;
}());
/**
 * copy from v3 legacy storage
 * uses memory to cache event data.
 */
var MemoStorage = /** @class */ (function () {
    function MemoStorage() {
        var _this = this;
        this.backStore = {};
        this.storage = {
            get: function (key) {
                return _this.backStore[key];
            },
            set: function (key, value) {
                _this.backStore[key] = value;
                return true;
            },
        };
        this.queue = new Queue(this.storage, MemoStorage.QUEUE_STORAGE_KEY);
    }
    MemoStorage.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // console.log('init memo storage');
                return [2 /*return*/, void 0];
            });
        });
    };
    MemoStorage.prototype.addEvent = function (data) {
        this.queue.enqueue(data);
        return Promise.resolve();
    };
    MemoStorage.prototype.getEvents = function (limit) {
        var data = limit === -1 ? this.queue.get() : this.queue.batchDequeue(limit);
        return Promise.resolve({ data: data });
    };
    MemoStorage.prototype.resetEvents = function (_, data) {
        this.queue.putBackBatchToQueue(data);
        return Promise.resolve();
    };
    MemoStorage.prototype.removeEvents = function (_) {
        // memo storage already remove event when get events
        return Promise.resolve();
    };
    MemoStorage.prototype.getSession = function (flag, func) {
        var seqKey = MemoStorage.SESSION_STORAGE_KEY + '::' + flag;
        var session = this.storage.get(MemoStorage.SESSION_STORAGE_KEY);
        var sequenceId = this.storage.get(seqKey);
        session =
            session && 'sessionId' in session && typeof sequenceId === 'number' && 'timestamp' in session
                ? {
                    sequenceId: sequenceId,
                    timestamp: session.timestamp,
                    sessionId: session.sessionId,
                }
                : void 0; // clear legacy data
        session = func(session);
        this.storage.set(MemoStorage.SESSION_STORAGE_KEY, { sessionId: session.sessionId, timestamp: session.timestamp });
        this.storage.set(seqKey, session.sequenceId);
        return Promise.resolve(session);
    };
    MemoStorage.prototype.getCurrentSessionId = function () {
        var session = this.storage.get(MemoStorage.SESSION_STORAGE_KEY);
        var sessionId = session && 'sessionId' in session ? session.sessionId : void 0;
        return Promise.resolve(sessionId);
    };
    MemoStorage.prototype.removeExpiredEvents = function () {
        // console.log('call removeExpiredEvents in memo cache');
        return Promise.resolve();
    };
    MemoStorage.QUEUE_STORAGE_KEY = 'bi-tracking::events';
    MemoStorage.SESSION_STORAGE_KEY = 'bi-tracking::session';
    MemoStorage.CHECK_STORAGE_KEY = 'bi-tracking::check';
    return MemoStorage;
}());// https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB
// https://stackoverflow.com/questions/40593260/should-i-open-an-idbdatabase-each-time-or-keep-one-instance-open
// https://stackoverflow.com/questions/13972385/invalidstateerror-while-opening-indexeddb-in-firefox
var IndexedDBStorage = /** @class */ (function () {
    function IndexedDBStorage(version) {
        if (version === void 0) { version = 4; }
        this.DATABASE_VERSION = 4;
        this.DATABASE_VERSION = version;
    }
    // Check the initialization status of opening indexedDB. Any rejection can suggest
    // inavailbility of indexedDB, and should fallback to localstorage.
    IndexedDBStorage.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var db;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.openDB(IndexedDBStorage.DATABASE_NAME, this.DATABASE_VERSION)];
                    case 1:
                        db = _a.sent();
                        this.idb = db;
                        return [2 /*return*/];
                }
            });
        });
    };
    // $FlowFixMe
    IndexedDBStorage.prototype.upgrade = function (db, event) {
        if (event.oldVersion < this.DATABASE_VERSION) {
            // remove all of the old event
            if (db.objectStoreNames.contains(IndexedDBStorage.OBJECT_STORE_EVENTS)) {
                db.deleteObjectStore(IndexedDBStorage.OBJECT_STORE_EVENTS);
            }
            if (
            // $FlowFixMe
            db.objectStoreNames.contains(IndexedDBStorage.OBJECT_STORE_EVENTS_V1)) {
                db.deleteObjectStore(IndexedDBStorage.OBJECT_STORE_EVENTS_V1);
            }
            if (
            // $FlowFixMe
            db.objectStoreNames.contains(IndexedDBStorage.OBJECT_STORE_SESSIONS_V1)) {
                db.deleteObjectStore(IndexedDBStorage.OBJECT_STORE_SESSIONS_V1);
            }
        }
        if (
        // $FlowFixMe
        !db.objectStoreNames.contains(IndexedDBStorage.OBJECT_STORE_EVENTS)) {
            var eventStore = db.createObjectStore(IndexedDBStorage.OBJECT_STORE_EVENTS, {
                autoIncrement: true,
            });
            eventStore.createIndex(IndexedDBStorage.INDEX_EVENTS_FETCHED, IndexedDBStorage.INDEX_EVENTS_FETCHED, {
                unique: false,
            });
            eventStore.createIndex(IndexedDBStorage.INDEX_EVENT_TIMESTAMP, IndexedDBStorage.INDEX_EVENT_TIMESTAMP, {
                unique: false,
            });
        }
        if (
        // $FlowFixMe
        !db.objectStoreNames.contains(IndexedDBStorage.OBJECT_STORE_SESSIONS)) {
            db.createObjectStore(IndexedDBStorage.OBJECT_STORE_SESSIONS);
        }
    };
    IndexedDBStorage.prototype.openDB = function (dbname, version) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var request = self.window.indexedDB.open(dbname, version);
            request.onblocked = function () {
                console.warn('[IndexedDBStorage] Upgrade is blocked since connection to old version exists.');
            };
            request.onerror = function (event) {
                try {
                    event.preventDefault();
                    // eslint-disable-next-line no-empty
                }
                catch (e) { }
                reject(event);
            };
            request.onsuccess = function () {
                var db = request.result;
                if (!db.objectStoreNames.contains(IndexedDBStorage.OBJECT_STORE_EVENTS) ||
                    !db.objectStoreNames.contains(IndexedDBStorage.OBJECT_STORE_SESSIONS)) {
                    // I decided not to recreate ObjectStore since it's risky to create
                    // Store in a onsuccess handler.
                    reject('Required ObjectStore cannot be found.');
                }
                else {
                    db.onerror = function (ev) {
                        console.warn('[IndexedDBStorage]', ev.errorCode);
                    };
                    db.onversionchange = function () {
                        db.close();
                        console.warn('[IndexedDBStorage] A new version of indexedDB is ready.');
                    };
                    resolve(db);
                }
            };
            // Legacy Chrome has a bug that won't trigger onupgradeneeded, we just
            // fallback to localstorage.
            request.onupgradeneeded = function (event) {
                var db = request.result;
                try {
                    _this.upgrade(db, event);
                }
                catch (e) {
                    reject(e);
                }
            };
        });
    };
    IndexedDBStorage.prototype.addEvent = function (data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var transaction = _this.idb.transaction(IndexedDBStorage.OBJECT_STORE_EVENTS, 'readwrite');
            transaction.oncomplete = function () {
                resolve();
            };
            transaction.onerror = function (event) {
                reject(event);
            };
            transaction.onabort = function (event) {
                reject(event);
            };
            transaction.objectStore(IndexedDBStorage.OBJECT_STORE_EVENTS).add({
                data: JSON.stringify(data),
                timestamp: Date.now(),
                fetched: 'f',
            });
        });
    };
    /**
     *
     * @param limit set -1 to get all of the event
     * @returns
     */
    IndexedDBStorage.prototype.getEvents = function (limit) {
        var _this = this;
        // just get data, not remove them
        var keys = [];
        var data = [];
        return new Promise(function (resolve, reject) {
            var transaction = _this.idb.transaction(IndexedDBStorage.OBJECT_STORE_EVENTS, 'readwrite');
            transaction.oncomplete = function () {
                resolve({ keys: keys, data: data });
            };
            transaction.onerror = function (event) {
                reject(event);
            };
            transaction.onabort = function (event) {
                reject(event);
            };
            // Only get events that are not being processed so as to avoid
            // duplicate sending issue.
            // $FlowFixMe
            var keyrange = IDBKeyRange.only('f');
            var request = transaction
                .objectStore(IndexedDBStorage.OBJECT_STORE_EVENTS)
                .index(IndexedDBStorage.INDEX_EVENTS_FETCHED)
                .openCursor(keyrange);
            request.onsuccess = function () {
                var cursor = request.result;
                if (cursor) {
                    keys.push(cursor.primaryKey);
                    data.push(JSON.parse(cursor.value.data));
                    cursor.update(__assign(__assign({}, cursor.value), { fetched: 't' }));
                    if (limit === -1 || limit-- > 1) {
                        cursor.continue();
                    }
                }
            };
        });
    };
    IndexedDBStorage.prototype.resetEvents = function (keys) {
        var _this = this;
        if (!keys || keys.length <= 0) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var transaction = _this.idb.transaction(IndexedDBStorage.OBJECT_STORE_EVENTS, 'readwrite');
            transaction.oncomplete = function () {
                resolve();
            };
            transaction.onerror = function (event) {
                reject(event);
            };
            transaction.onabort = function (event) {
                reject(event);
            };
            var keyrange = IDBKeyRange.bound(keys[0], keys[keys.length - 1]);
            var request = transaction.objectStore(IndexedDBStorage.OBJECT_STORE_EVENTS).openCursor(keyrange);
            request.onsuccess = function () {
                var cursor = request.result;
                if (cursor) {
                    cursor.update(__assign(__assign({}, cursor.value), { fetched: 'f' }));
                    cursor.continue();
                }
            };
        });
    };
    IndexedDBStorage.prototype.removeEvents = function (keys) {
        var _this = this;
        if (!keys || keys.length <= 0) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var transaction = _this.idb.transaction(IndexedDBStorage.OBJECT_STORE_EVENTS, 'readwrite');
            transaction.oncomplete = function () {
                resolve();
            };
            transaction.onerror = function (event) {
                reject(event);
            };
            transaction.onabort = function (event) {
                reject(event);
            };
            // $FlowFixMe
            var keyrange = IDBKeyRange.bound(keys[0], keys[keys.length - 1]);
            transaction.objectStore(IndexedDBStorage.OBJECT_STORE_EVENTS).delete(keyrange);
        });
    };
    IndexedDBStorage.prototype.getSession = function (flag, fn) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var session;
            var seqKey = IndexedDBStorage.KEY_SESSION + '::' + flag;
            var transaction = _this.idb.transaction(IndexedDBStorage.OBJECT_STORE_SESSIONS, 'readwrite');
            transaction.oncomplete = function () {
                resolve(session);
            };
            transaction.onerror = function (event) {
                reject(event);
            };
            transaction.onabort = function (event) {
                reject(event);
            };
            var store = transaction.objectStore(IndexedDBStorage.OBJECT_STORE_SESSIONS);
            Promise.all([
                new Promise(function (res, rej) {
                    var sessionReq = store.get(IndexedDBStorage.KEY_SESSION);
                    sessionReq.onsuccess = function () { return res(sessionReq.result); };
                    sessionReq.onerror = function () { return rej(); };
                }),
                new Promise(function (res, rej) {
                    var seqReq = store.get(seqKey);
                    seqReq.onsuccess = function () { return res(seqReq.result); };
                    seqReq.onerror = function () { return rej(); };
                }),
            ]).then(function (_a) {
                var rawSession = _a[0], sequenceId = _a[1];
                if (rawSession && typeof sequenceId === 'number') {
                    session = fn(__assign(__assign({}, rawSession), { sequenceId: sequenceId }));
                }
                else {
                    session = fn();
                }
                store.put({ sessionId: session.sessionId, timestamp: session.timestamp }, IndexedDBStorage.KEY_SESSION);
                store.put(session.sequenceId, seqKey);
            });
        });
    };
    IndexedDBStorage.prototype.getCurrentSessionId = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var session;
            var transaction = _this.idb.transaction(IndexedDBStorage.OBJECT_STORE_SESSIONS, 'readwrite');
            transaction.oncomplete = function () {
                resolve(session === null || session === void 0 ? void 0 : session.sessionId);
            };
            transaction.onerror = function (event) {
                reject(event);
            };
            transaction.onabort = function (event) {
                reject(event);
            };
            var store = transaction.objectStore(IndexedDBStorage.OBJECT_STORE_SESSIONS);
            var request = store.get(IndexedDBStorage.KEY_SESSION);
            request.onsuccess = function () {
                session = request.result;
            };
        });
    };
    /**
     * Events are cached locally with retention policy set as 3 days. And data
     * will be removed when they are expired before they get a chance to be sent.
     */
    IndexedDBStorage.prototype.removeExpiredEvents = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var transaction = _this.idb.transaction(IndexedDBStorage.OBJECT_STORE_EVENTS, 'readwrite');
            transaction.oncomplete = function () {
                resolve();
            };
            transaction.onerror = function (event) {
                reject(event);
            };
            transaction.onabort = function (event) {
                reject(event);
            };
            // $FlowFixMe
            var keyrange = IDBKeyRange.upperBound(Date.now() - IndexedDBStorage.RETENTION);
            var request = transaction
                .objectStore(IndexedDBStorage.OBJECT_STORE_EVENTS)
                .index(IndexedDBStorage.INDEX_EVENT_TIMESTAMP)
                .openCursor(keyrange);
            request.onsuccess = function () {
                var cursor = request.result;
                if (cursor) {
                    cursor.delete();
                    cursor.continue();
                }
            };
        });
    };
    IndexedDBStorage.DATABASE_NAME = 'data-tracking';
    IndexedDBStorage.OBJECT_STORE_EVENTS_V1 = 'events';
    IndexedDBStorage.OBJECT_STORE_EVENTS = 'events_v2';
    IndexedDBStorage.OBJECT_STORE_SESSIONS_V1 = 'sessions';
    IndexedDBStorage.OBJECT_STORE_SESSIONS = 'session_v2';
    IndexedDBStorage.INDEX_EVENTS_FETCHED = 'fetched';
    IndexedDBStorage.INDEX_EVENT_TIMESTAMP = 'timestamp';
    IndexedDBStorage.KEY_SESSION = 'current_session';
    IndexedDBStorage.RETENTION = 172800000; // 2 days
    return IndexedDBStorage;
}());// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}var latestEventId = '';
var latestViewPageType = '';
var SessionManager = /** @class */ (function () {
    function SessionManager() {
    }
    SessionManager.prototype.useStorage = function (storage) {
        if (!this.trackerStorage) {
            this.trackerStorage = storage;
            // console.log('initialize storage');
            return;
        }
        if (storage instanceof IndexedDBStorage && this.trackerStorage instanceof MemoStorage) {
            this.trackerStorage = storage;
            // console.log('use IndexedDBStorage');
            return;
        }
        console.warn('There is already an IndexedDBStorage / memostorage in session manager, can not update storage.');
    };
    SessionManager.prototype.getSession = function (flag, reset) {
        if (reset === void 0) { reset = false; }
        return __awaiter(this, void 0, void 0, function () {
            var trackingStorage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        trackingStorage = this.trackerStorage;
                        return [4 /*yield*/, trackingStorage.getSession(flag, function (session) {
                                var currentTimestamp = Date.now();
                                if (reset === true ||
                                    session === null ||
                                    typeof session === 'undefined' ||
                                    currentTimestamp - session.timestamp > SessionManager.SESSION_DURATION) {
                                    session = {
                                        sessionId: v4(),
                                        timestamp: currentTimestamp,
                                        sequenceId: 0,
                                    };
                                }
                                else {
                                    // When the underlying storage is indexedDB, increment of sequenceId
                                    // is within a transaction, so atomicity can be guaranteed.
                                    session.sequenceId += 1;
                                    session.timestamp = currentTimestamp;
                                }
                                return session;
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    SessionManager.prototype.GetSessionId = function (flag, reset) {
        if (reset === void 0) { reset = false; }
        return __awaiter(this, void 0, void 0, function () {
            var trackingStorage, id, session;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        trackingStorage = this.trackerStorage;
                        return [4 /*yield*/, trackingStorage.getCurrentSessionId()];
                    case 1:
                        id = _a.sent();
                        if (id) {
                            return [2 /*return*/, id];
                        }
                        return [4 /*yield*/, this.getSession(flag, reset)];
                    case 2:
                        session = _a.sent();
                        return [2 /*return*/, session.sessionId];
                }
            });
        });
    };
    /**
     * `setLatestEventId` and `getLatestEventId` are used for CIV association,
     * that is to tag event of type click, impression, view with id of the
     * latest auto_view event.
     */
    SessionManager.prototype.setLatestEventId = function (eventId) {
        latestEventId = eventId;
    };
    SessionManager.prototype.getLatestEventId = function () {
        return latestEventId;
    };
    /**
     * `setLatestViewPageType` and `getLatestViewPageType` are used to cache page type
     * for latest view event, so we can associate it with auto_view event as auto_mapped_view
     * so that we can easily map auto_view with view at the backend.
     * (Although, this is not quite reliable)
     */
    SessionManager.prototype.setLatestViewPageType = function (pageType) {
        latestViewPageType = pageType;
    };
    SessionManager.prototype.getLatestViewPageType = function () {
        return latestViewPageType;
    };
    SessionManager.SESSION_DURATION = 30 * 60 * 1000; // 30 minutes by default
    return SessionManager;
}());
// singleton
var trackingSessionManager = new SessionManager();function detectBrowser() {
    // not browser env
    if (typeof navigator === 'undefined') {
        return 'unknown';
    }
    if (navigator.userAgent.indexOf('Chrome') !== -1) {
        return 'Chrome';
    }
    // FIREFOX
    else if (navigator.userAgent.indexOf('Firefox') !== -1) {
        return 'Firefox';
    }
    // INTERNET EXPLORER
    else if (navigator.userAgent.indexOf('MSIE') !== -1) {
        return 'Internet Exploder'; // intend to be Internet Exploder
    }
    // EDGE
    else if (navigator.userAgent.indexOf('Edge') !== -1) {
        return 'Edge';
    }
    // SAFARI
    else if (navigator.userAgent.indexOf('Safari') !== -1) {
        return 'Safari';
    }
    // OPERA
    else if (navigator.userAgent.indexOf('Opera') !== -1) {
        return 'Opera';
    }
    // OTHERS
    else {
        return 'Others';
    }
}
function detectConnection() {
    // not browser env
    if (typeof navigator === 'undefined') {
        return 'unknown';
    }
    var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    return (connection && connection.effectiveType) || 'unknown';
}
function detectOS() {
    var OSName = 'Unknown OS';
    if (navigator.appVersion.indexOf('Win') != -1)
        OSName = 'Windows';
    if (navigator.appVersion.indexOf('Mac') != -1)
        OSName = 'MacOS';
    if (navigator.appVersion.indexOf('X11') != -1)
        OSName = 'UNIX';
    if (navigator.appVersion.indexOf('Linux') != -1)
        OSName = 'Linux';
    return OSName;
}function getCookie(name) {
    // not browser env
    if (typeof document === 'undefined') {
        return;
    }
    // from stackoverflow
    var value = "; " + document.cookie;
    var parts = value.split("; " + name + "=");
    if (parts.length === 2)
        return parts.pop().split(';').shift();
}var image = {
	SG: "cf.shopee.sg",
	TW: "cf.shopee.tw",
	MY: "cf.shopee.com.my",
	PH: "cf.shopee.ph",
	TH: "cf.shopee.co.th",
	ID: "cf.shopee.co.id",
	VN: "cf.shopee.vn",
	BR: "cf.shopee.com.br",
	MX: "cf.shopee.com.mx",
	CO: "cf.shopee.com.co",
	CL: "cf.shopee.cl"
};
var assets = {
	SG: "deo.shopeemobile.com/shopee",
	TW: "deo.shopeemobile.com/shopee",
	MY: "deo.shopeemobile.com/shopee",
	PH: "deo.shopeemobile.com/shopee",
	TH: "deo.shopeemobile.com/shopee",
	ID: "deo.shopeemobile.com/shopee",
	VN: "deo.shopeemobile.com/shopee",
	BR: "deo.shopeemobile.com/shopee",
	MX: "deo.shopeemobile.com/shopee",
	CO: "deo.shopeemobile.com/shopee",
	CL: "deo.shopeemobile.com/shopee"
};
var mall = {
	SG: "shopee.sg",
	TW: "shopee.tw",
	MY: "shopee.com.my",
	PH: "shopee.ph",
	TH: "shopee.co.th",
	ID: "shopee.co.id",
	VN: "shopee.vn",
	BR: "shopee.com.br",
	MX: "shopee.com.mx",
	CO: "shopee.com.co",
	CL: "shopee.cl"
};
var admin = {
	SG: "admin.shopee.sg",
	TW: "admin.shopee.tw",
	MY: "admin.shopee.com.my",
	PH: "admin.shopee.ph",
	TH: "admin.shopee.co.th",
	ID: "admin.shopee.co.id",
	VN: "admin.shopee.vn",
	BR: "admin.shopee.com.br",
	MX: "admin.shopee.com.mx",
	CO: "admin.shopee.com.co",
	CL: "admin.shopee.cl"
};
var video = {
	SG: "cv.shopee.sg",
	TW: "cv.shopee.tw",
	MY: "cv.shopee.com.my",
	PH: "cv.shopee.ph",
	TH: "cv.shopee.co.th",
	ID: "cv.shopee.co.id",
	VN: "cv.shopee.vn",
	BR: "cv.shopee.com.br",
	MX: "cv.shopee.com.mx",
	CO: "cv.shopee.com.co",
	CL: "cv.shopee.cl"
};
var env = {
	test: "test.",
	stable: "test-stable.",
	staging: "staging.",
	liveish: "live-test.",
	live: "",
	sandbox: "sandbox.",
	uat: "uat."
};
var cid = {
	SG: ".sg",
	TW: ".tw",
	MY: ".com.my",
	PH: ".ph",
	TH: ".co.th",
	ID: ".co.id",
	VN: ".vn",
	BR: ".com.br",
	MX: ".com.mx",
	CO: ".com.co",
	CL: ".cl"
};
var walletCid = {
	PH: ".com.ph"
};
var SHOPEE_DOMAIN_ENV = {
	image: image,
	assets: assets,
	mall: mall,
	admin: admin,
	video: video,
	env: env,
	cid: cid,
	walletCid: walletCid
};var ENV_PREFIX = __assign(__assign({}, SHOPEE_DOMAIN_ENV.env), { liveish: '' });
function getEndpoint(env, locale, postfix) {
    return "https://c-api-bit." + ENV_PREFIX[env] + "shopeemobile.com/" + locale + "/" + postfix;
}/**
 * Schedule callback when idle to help ensure that app logic responding
 * to the URL change happens prior to this.
 * @param {*} callback function to be deferred
 */
function scheduleWhenIdle(callback) {
    if (typeof requestIdleCallback !== 'undefined') {
        requestIdleCallback(function () { return callback(); }, { timeout: 500 });
    }
    else {
        callback();
    }
}
function sleep(timeout) {
    return new Promise(function (res) {
        setTimeout(function () {
            res();
        }, timeout);
    });
}
// get byteSize of a string
var byteSize = typeof Blob !== 'undefined' ? function (str) { return new Blob([str]).size; } : function (str) { return str.length; };
function getDEDeviceID() {
    var keyname = 'de_device_id';
    var id = '';
    try {
        id = localStorage.getItem(keyname);
        if (!id) {
            id = v4();
            localStorage.setItem(keyname, id);
        }
    }
    catch (error) {
        console.warn(error, 'gerenate by uuid');
        id = v4();
    }
    return id;
}function post(url, options) {
    var headers = Object.assign({ 'Content-Type': 'application/json' }, options === null || options === void 0 ? void 0 : options.headers);
    if (typeof fetch !== 'undefined') {
        return fetch(url, {
            method: 'POST',
            headers: headers,
            body: options.body,
        });
    }
    return new Promise(function (res, rej) {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', url);
        Object.keys(headers).forEach(function (h) {
            xhr.setRequestHeader(h, headers[h]);
        });
        xhr.onload = function () {
            res(xhr.response);
        };
        xhr.onerror = function () {
            rej(xhr.response);
        };
        xhr.send(options.body);
    });
}
function sendBeacon(url, data) {
    if (typeof navigator !== 'undefined' && navigator.sendBeacon) {
        navigator.sendBeacon(url, data);
    }
    else {
        // fallback
        post(url, { headers: { 'Content-Type': 'application/json' }, body: data });
    }
}
function withRetry(func, BACK_OFF, retryTime) {
    if (BACK_OFF === void 0) { BACK_OFF = 1000; }
    return func().catch(function (err) {
        console.warn(err);
        if (typeof retryTime === 'number') {
            retryTime--;
        }
        if (retryTime > 0 || retryTime === 'INF') {
            return sleep(Math.min(BACK_OFF, 20000)).then(function () { return withRetry(func, BACK_OFF * 2, retryTime); });
        }
        return Promise.reject(err);
    });
}
function getContentSize(d) {
    try {
        return byteSize(JSON.stringify(d));
    }
    catch (error) {
        return 0;
    }
}
/**
 *
 * @param byte default 4.5mb 4.5e6
 */
function constraintSize(data, spliter, byte) {
    if (byte === void 0) { byte = 1e6; }
    var result = [data];
    var originSize = getContentSize(data);
    var perferedCount = Math.ceil(originSize / byte);
    if (perferedCount < 2) {
        return result;
    }
    while (result.length < perferedCount) {
        var temp = result.reduce(function (am, curr) {
            var eles = spliter(curr);
            am.push.apply(am, eles);
            return am;
        }, []);
        // means no changes
        if (!(temp.length > result.length)) {
            break;
        }
        result = temp;
    }
    return result;
}var Scheduler = /** @class */ (function () {
    function Scheduler(opt) {
        this.INTERVAL_PERIOD = 10000;
        this.enable = true;
        Object.assign(this, opt);
        this.intervalCallee();
        this.unloadCallee();
    }
    Scheduler.prototype.onInterval = function () {
        return Promise.resolve();
    };
    Scheduler.prototype.onFinish = function () {
        return Promise.resolve();
    };
    Scheduler.prototype.onError = function (_) {
        return Promise.resolve();
    };
    Scheduler.prototype.onUnload = function () {
        return void 0;
    };
    Scheduler.prototype.unloadCallee = function () {
        var _this = this;
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'hidden') {
                _this.onUnload();
                // console.log('this.onUnload when visibilitychange');
            }
        });
        window.addEventListener('pagehide', function () {
            _this.onUnload();
            // console.log('this.onUnload when pagehide');
        }, false);
        window.onbeforeunload = function () {
            _this.onUnload();
            // console.log('this.onUnload when onbeforeunload');
            return;
        };
    };
    Scheduler.prototype.intervalCallee = function () {
        var _this = this;
        if (!this.enable) {
            return;
        }
        // send and set a timer
        this.onInterval()
            .then(this.onFinish)
            .catch(this.onError)
            .then(function () { return sleep(_this.INTERVAL_PERIOD); })
            .then(function () { return _this.intervalCallee(); });
    };
    /**
     * not need in most cases
     */
    Scheduler.prototype.trigger = function (status) {
        this.enable = status;
        // console.log('[scheduler]', this.enable);
    };
    return Scheduler;
}());var ITracker = /** @class */ (function () {
    function ITracker(opt) {
        this.options = opt;
    }
    ITracker.prototype.init = function () {
        throw 'no implement';
    };
    ITracker.prototype.logDirectly = function (processedData) {
        throw 'no implement';
    };
    ITracker.prototype.logBatchly = function (processedData) {
        throw 'no implement';
    };
    ITracker.prototype.logJSBridge = function (processedData) {
        throw 'no implement';
    };
    ITracker.prototype.preProcess = function (eventData) {
        throw 'no implement';
    };
    ITracker.prototype.initScheduler = function () {
        throw 'no implement';
    };
    /**
     * [public method] no need to refactor
     * @param data
     */
    ITracker.prototype.logEvent = function (data) {
        var _this = this;
        scheduleWhenIdle(function () {
            _this.realLogEvent(data);
        });
    };
    /**
     * [private] inner router
     * @param {TData} eventData refer to protobuf schema and js sdk tech design
     */
    ITracker.prototype.realLogEvent = function (eventData) {
        var _this = this;
        return this.preProcess(eventData).then(function (precessed) {
            // if jsbridge
            // this.logJSBridge(apmsData);
            if (_this.options.sendImmediately) {
                return _this.logDirectly(precessed);
            }
            return _this.logBatchly(precessed);
        });
    };
    return ITracker;
}());var runningInstance = new Map();exports.ITracker=ITracker;exports.IndexedDBStorage=IndexedDBStorage;exports.MemoStorage=MemoStorage;exports.Scheduler=Scheduler;exports.byteSize=byteSize;exports.constraintSize=constraintSize;exports.detectBrowser=detectBrowser;exports.detectConnection=detectConnection;exports.detectOS=detectOS;exports.getCookie=getCookie;exports.getDEDeviceID=getDEDeviceID;exports.getEndpoint=getEndpoint;exports.post=post;exports.runningInstance=runningInstance;exports.scheduleWhenIdle=scheduleWhenIdle;exports.sendBeacon=sendBeacon;exports.sleep=sleep;exports.trackingSessionManager=trackingSessionManager;exports.uuidv4=v4;exports.withRetry=withRetry;Object.defineProperty(exports,'__esModule',{value:true});});